var $queueTable      = {}, // Keep track of the order in which classes extend each other.
    $childTable      = {}, // ...           which parent a child has.
    $dependencyTable = {}, // ...           which children a parent has.
    $dependencyStack = []; // Order in which classes should be extended.

/*
    Solve all dependencies before the Main class is called.
*/
function $solveDependencies() {
    $appendSuperClasses();  // Always set the prototype of top level classes first.
    $extendSuperClasses();
}

/*
    All top level classes that are not extended just grab all the
    properties from append and insert them into the prototype.
*/
function $appendSuperClasses() {
    var classes = Object.keys(CLASS);
    
    for (var i = 0, max = classes.length; i < max; i++) {
        var n = classes[i],  // Class name.
            c = CLASS[n];
        
        if (c.append && !$childTable[n]) {
            c.prototype = c.append; // Copy into the prototype.
            
            c.append = undefined;   // Just reference the prototype.
        } else {
            // If append was not declared, just point to a empty object.
            c.prototype = {};
        }
        
        c.prototype.constructor = c; // Set the constructor.
    }
}

/*
    Using the dependency stack, extend all super classes to their defined
    children.
*/
function $extendSuperClasses() {
    var stack = $dependencyStack;
    
    /*
        Traverse through all the parents and children in the
        dependency table.
    */
    for (var i = 0, iMax = stack.length; i < iMax; i++) {
        var parent   = stack[i],
            children = $dependencyTable[parent];
        
        for (var j = 0, jMax = children.length; j < jMax; j++) {
            var child = children[j];
            
            $linkPrototype(parent, child);
        }
    }
}

/*
    Link the parent's prototype to the child prototype.
    The append hash can override any methods the parent
    prototype has.
*/
function $linkPrototype(from, to) {
    var child  = CLASS[to],   // Child class.
        parent = CLASS[from]; // Parent class.
    
    /*
        Stop program if parent or child do not exist.
    */
    if (!parent || !child) {
        throw new Error(from + ' cannot link to ' + to + '.');
    }
    
    // Link to the parent's prototype.
    child.prototype = Object.create(parent.prototype);
    
    if (child.append) {
        var keys = Object.keys(child.append);
        
        // Copy all the properties in append into the prototype.
        for (var i = 0, max = keys.length; i < max; i++) {
            var property = keys[i];
            
            child.prototype[property] = child.append[property];
        }
    }
    
    child.prototype.constructor = child;
    
    child.append = undefined;
}

/*
    Fix the order in which classes are extended.
*/
function $swapParent(child) {
    var stack    = $dependencyStack,
        parent   = $childTable[child],      // The parent which the child references.
        newStack = new Array(stack.length); // New array that will replace the old stack.
    
    /*
        Swap the parent with the child. At a certain point the newStack will be 
        offset by one to copy all the remaining indexes in the old stack.
    */
    for (var i = 0, j = 0, max = stack.length; i < max; i++) {
        if (stack[i] === child) {
            newStack[j]   = parent;
            newStack[j++] = child;
        } else if (stack[i] !== parent) {
            newStack[j] = stack[i];
        }
        
        j++;
    }
    
    $dependencyStack = newStack; // Reference the new stack.
}

/*
    Keep reference of the parent and child class names to solve all
    the dependencies before the program starts.
*/
function extend(parent, child) {
    // If hash is undefined. Create a new array for that hash.
    if (!$dependencyTable[parent]) { $dependencyTable[parent] = []; }
    
    $dependencyTable[parent].push(child); // Keep track of new child in collection.
    
    // Do not allow child to inherit from more than one class.
    if ($childTable[child]) {
        throw new Error(child + ' cannot inherit more than once.');
    }
    
    // Push parent into stack if it has not been queued yet.
    if (!$queueTable[parent]) { 
        $dependencyStack.push(parent);
        $queueTable[parent] = true;
    }
    
    /*
        Has child been already added as a parent?
        Fix stack order if true.
    */
    if ($queueTable[child]) {
        $swapParent(child);       
    }
    
    $childTable[child] = parent; // Point to which parent the child is extending.
}
